<!-- GFM-TOC -->
* [计算机网络](#计算机网络)
    * [针对Web的攻击技术XSS与CSRF](#针对Web的攻击技术XSS与CSRF)
    * [TCP的三次握手和四次挥手](#TCP的三次握手和四次挥手)
    * [HTTP和HTTPS的区别](#HTTP和HTTPS的区别)
    * [HTTP1.0、HTTP1.1和HTTP2.0的区别](#HTTP1.0HTTP1.1和HTTP2.0的区别)
    * [从输入URL到页面加载完成的过程](#从输入URL到页面加载完成的过程)
* [参考文献](#参考文献)
<!-- GFM-TOC -->

# 计算机网络
## 针对Web的攻击技术
HTTP协议内并不具备 `会话(session)管理`、`加密处理`等安全性方面的功能。在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由的变更、篡改。所以Web应用可能会接收到与预期数据不相同的内容。

在HTTP请求报文内家在攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全泄漏，那内部信息就会遭到窃取，或者被攻击者拿到管理权限

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-35.png' width=520 height=320>

对Web应用对攻击模式有两种 : 
- 主动攻击

- 被动攻击

### 以服务器为目标的主动攻击

主动攻击是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上对的资源进行攻击，因此攻击者需要能够访问到那些资源，主动攻击模式里，最具有代表性的是 : `SQL注入攻击` 和 `OS命令注入攻击`

#### 以服务器为目标的被动攻击
被动攻击是指利用圈套策略执行攻击代码的攻击模式，通常都是诱导用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。执行完攻击代码之后，可能会导致用户所持有的Cookie等个人信息被窃取，登陆状态中的用户权限遭到恶意滥用等后果

被动攻击模式最具有代表性的是 : `跨站脚本攻击（XSS）`和 `跨站请求伪造（CSRF）`

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-36.png' width=520 height=320>

### 利用用户身份攻击企业内部网络
利用被动攻击，可发起对原本从互联网上无法直接访问的企业内部等网络的攻击。只要用户踏入攻击者预先设定好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。

-------

### 使用XSS攻击
xss叫做跨站脚本攻击，是一种web应用中的计算机漏洞，当用户浏览器渲染整个HTML文档的过程中出现了不被预期的脚本指令并执行时，XSS就会发生。(这个逼装的好，鼓个掌) 

它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。

#### XSS 分为三种
```base
反射型XSS : 这种xss，跨站代码一般存在于某一个链接中，当被攻击者访问这样的连接时，跨站代码就被执行，这类跨站代码一般不会存储在服务器上面
```
```base
存储型XSS : 这种xss用起来比较方便，跨站代码会存储在服务器上面数据库中，换句话就是可以持久的进行攻击，亦称持久型XSS
```
```基于DOM的XSS
基于DOM的XSS : 这是由于客户端脚本自身的解析不正确导致的安全问题
```
#### 如何攻击 ？
XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。
```html
    <!-- 比如在一个留言板中插入xss代码，前提是留言内容不过滤 -->
    
    <!-- 在文本框中添加 -->
    <script>alert('我是XSS攻击')</script>

    <!-- 这时候点击留言，脚本被执行，就会弹出对话框，这就说明存在XSS危害 -->
```
#### 如何预防 ？
最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义
```javascript
    function escape(str) {
        str = str.replace(/&/g, "&amp;");
        str = str.replace(/</g, "&lt;");
        str = str.replace(/>/g, "&gt;");
        str = str.replace(/"/g, "&quto;");
        str = str.replace(/'/g, "&##39;");
        str = str.replace(/`/g, "&##96;");
        str = str.replace(/\//g, "&##x2F;");
        return str
    }

    // 通过转义，将攻击代码变成
    escape('<script>alert(1)</script>')
    // &lt;script&gt;alert(1)&lt;&##x2F;script&gt;
```
--------

### CSRF跨站请求伪造

你可以这样理解 : 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 

#### 我们是实在人，举个实在例子
受害者 A 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=A&amount=1000000&for=B 可以使 A 把 1000000 的存款转到 B 的账号下。

通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

黑客 B 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=A&amount=1000000&for=B。但是这个请求来自 B 而非 A，他不能通过安全认证，因此该请求不会起作用。

这时，B 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=A&amount=1000000&for=B ”，并且通过广告等诱使 A 来访问他的网站。

当 A 访问该网站时，上述 url 就会从 A 的浏览器发向银行，而这个请求会附带 A 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 A 的认证信息。

但是！！！如果 A 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 A 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 A 的账号转移到 B 的账号，而 A 当时毫不知情。

等以后 A 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 B 则可以拿到钱后逍遥法外。 

#### 如何防御
```base
    1 、 验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的
    
    2 、 在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。
    
    3 、 在 HTTP 头中自定义属性并验证。可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击
```

--------

### SQL注入攻击
SQl注入攻击是指针对Web应用使用的数据库，通过运行非法的SQL语句而产生的攻击。正常情况下：从book表中搜索作者author = 'PDK' 且 flag = 1 的符合数据
```javascript
  URL: http://www.pengdaokuan.cn/search?q=PDK  
```
然后在SQL语句为: 
```sql
  SELECT * FROM book WHERE author = 'PDK' and flag = 1;
```
但是如果通过把查询字段改为： `PDK` -> `PDK--`
那么构成的SQl语句就变成了这样
```sql
  SELECT * FROM book WHERE author = 'PDK' --' and flag = 1;
```
SQL语句中的`--`之后全视为注释，即，and flag = 1 这个条件被自动忽略了！

--------

### HTTP首部注入攻击
HTTP首部注入攻击是值攻击者通过在响应首部字段内插入换行，添加任意响应首部或者主体的一种攻击。输入被动攻击模式

向首部主体内添加内容的攻击称为HTTP响应截断攻击，Web应用有时会把外部接收到的数值，赋给响应首部字段 `Location` 和 `Set-Cookie`

```javascript
  Location: http://www.pengdaokuan.cn/a.php?q=pdk
  Set-Cookie: UID=pdk

  *pdk就是插入值
```
HTTP首部注入攻击有可能会造成以下一些影响
- 设置任何 Cookie 信息

- 重定向至任意URL

- 显示任意的主体(HTTP响应截断攻击)


---------

### 开放重定向
开放重定向是一种对指定的任意URL作重定向跳转的功能。而于此功能相关联的安全漏洞是指: 加入指定的重定向URL到某个恶意的Web网站，那么用户就会被诱导至那个Web网站。

--------

### 会话劫持
是指通过某种手段拿到用户的会话ID，并没法使用此会话ID伪装成用户，达到攻击的目的。

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-37.png' width=520 height=320>

具备认证功能的Web应用，使用会话ID的会话管理机制，作为管理认证状态的主流方式。会话ID中记录客户端的Cookie等信息，服务器端将会话ID与认证状态进行一对一匹配管理

下面列举几种攻击者可获得会话ID的途径

- 通过非正规的生成方法推测会话ID

- 通过窃听或XSS攻击盗取会话ID

- 通过会话固定攻击强行获取会话ID


<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-38.png' width=520 height=320>

-------

### 其他安全漏洞

#### 密码破解
密码破解攻击即算出密码，突破认证。密码破解有以下两种手段: 
- 通过网络的密码试错 (两种方式: 穷举法和字典攻击)

> 穷举法，又称为暴力破解法，是对所有密钥集合构成的密钥空间进行穷举，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。比如银行采用“4位数字”组成的密码，那么就要从0000~9999中的全部数字进行逐个尝试。这样必定能在候选的密码集合中找到正确的密码，可通过认证，但时间太久，这种攻击是失败的。

> 字典攻击，利用实现收集好的候选密码(通过各种组合方式后存入字典)，枚举字典中的密码。尝试通过认证的一种攻击手段。比如银行采用“4位数字”组成的密码，考虑到用户可能会用自己的生日做密码，于是可以将0101~1231保存成字典，进行尝试。此方法攻击耗时相对穷举比较短，但是攻击的成败取决于字典的内容。如果字典中没有正确的密码，那么就无法破解成功

- 对已加密密码的破解

> web 应用在保存密码时，一般不会明文方式保存，而是通过散列函数做散列处理或者通过base64，md5等加密方式，所以想要取得真实密码，需要通过解码手段。把密码还原成明文形式。

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-39.png' width=520 height=320>

#### 点击劫持
点击劫持是值利用透明的按钮或链接做成陷阱，覆盖在web页面上，然后诱导用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)

----------

## TCP的三次握手和四次挥手
### 三次握手
<img src="http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png">

```javascript
    1 : 客户clientA发送SYN标志位和随机产生一个值seq=J给服务器B，此时处于SYN_SEND状态

    2 : 服务器B被动打开，处于Listen状态，服务器B接收到客户端A发送的请求后，如果同意请求连接，发送SYN标志位 和 ACK=J+1，随机产生一个值seq=K，此时进入到SYN_RCVD状态
    
    3 : 客户端A收到服务器B的确认之后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器B，此时进入established状态，服务器B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，此时进入established状态
```
为什么不是二次握手 ？
> 为了解决已失效的请求报文又传到B，因而产生错误。

比如A发送了一个请求给B，希望建立连接。但是由于此时此刻网络节点长或者拥塞滞留，这本来是一个失效的报文请求，但是因为A有一个超时时间，这时候会被认为超时重传。如果是两次握手请求，那么B这时候收到这个 “ 延迟 ”的报文请求A，会认为A又发送请求，于是B发送确认，这时候又建立起了连接。

### 四次挥手
<img src="http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png">

```javscript
    1 : 客户端A发送一个FIN告知服务器B，要结束连接，此时进入FIN_WAIT_1 状态

    2 : 服务器B收到FIN后，发送一个ACK给客户端A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器B进入CLOSE_WAIT，处于半关闭状态，也就是A不向B发数据，但B要向A传数据，客户端处于FIN_WAIT_2状态

    3 : 服务器B发送一个FIN，这时B没有东西要向A传了，所以发送FIN告知A可以关闭了，然后进入LAST_ACK状态

    4 : 客户端A收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器B，确认序号为收到序号+1，注意，这里还未释放掉，必须经过Time-wait(等待时间)，服务器B才进入CLOSED状态，完成四次挥手。
```

--------

## HTTP和HTTPS的区别
### 什么是HTTP，什么又是HTTPS ？
```base
HTTP是互联网最为广泛的网络传输协议，也叫做超文本传输协议。所有的WWW文件都必须遵守这个标准

HTTPS是以安全为目标到HTTP通道，说得直白一点，就是HTTP的安全版，在HTTP下加入了SSL层。
```
### HTTP的缺点
- 通信使用明文 (不加密)，内容可能会被窃听

- 不验证通信方的身份，可能遭遇伪装

- 无法证明报文的完整性，报文内容可能已被更改

### HTTP+加密+认证+完整性保护 = HTTPS
HTTP传输协议的数据是未加密的，也就是明文传输，因而很不安全，HTTPS协议就是由SSL + HTTP协议构建成的可进行加密传输、身份验证的网络协议。HTTP的端口在80，HTTPS的端口在443。并且HTTPS需要CA证书～

#### HTTPS是身披SSL外壳的HTTP
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信，但是使用SSL时，就演变成HTTP先和SSL通信，再由SSL和TCP通信。

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-26.png' width=550 height=480>

SSL采用了一种叫做 <strong>公开密钥加密</strong>的加密处理方式。那么是什么公开密钥加密呢？

> 公开密钥加密: 使用一对非对称的密钥，一把叫做公钥，一把叫做私钥；

使用公开密钥加密方式，发送密文的一方使用对方的`公开密钥`

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-27.png' width=640 height=500 />

### HTTPS的工作原理(简单版)
```javascript
    1 : 客户端使用http的url访问web服务器，要求与web服务器建立SSL连接

    2 : Web服务器接收到请求之后，会将网站的证书信息(证书中包含公钥)传送一份给客户端

    3 : 客户端的浏览器假假的对照一下证书信息，看看是不是本人，是的话与web服务器协商SSL连接的安全等级

    4 : 客户端的浏览器根据双方的安全等级，建立会话密钥。利用公钥对信息加密，传送给web服务器

    5 : web服务器用自己的私钥解密出会话信息，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密,从而与客户端通信
```

### HTTPS的通信步骤(详情版)

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-28.png' width=450 height=650 />

1 : 客户端发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL指定版本，加密组件列表(所使用的加密算法和密钥长度等)

2 : 服务器可进行SSL通信。会以Server Hello报文作为应答。和客户端一样，在报文中会包含SSL的版本以及加密组件；*服务器的加密组件内容是从客户端加密组件内筛选出来的*

3 : 服务器发送Certificate报文，报文中包含公钥证书

4 : 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束

5 : SSL第一次握手接受后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 `Pre-master-secret` 的随机密码串。报文已用步骤3中的服务器公开密钥进行加密

6 : 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，接下来的通信会采用 Pre-master-secret 密钥加密

7 : 客户端发送 Finished 报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准

8 : 服务器同样发送 Change Cipher Spec 报文

9 : 服务器同样发送 Finished 报文

10 : 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算简历完成。当然，通信会受SSL的保护

11 : 应用层协议通信，发送HTTP响应

12 : 最后由客户端断开连接，断开连接时，发送 close_notify 报文

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-29.png' width=720 height=520>

### HTTPS的优缺点
#### 优点 
1 : 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器

2 : HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性

3 : HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

4 : 相比之下，SEO更加友好

#### 缺点
1 : HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电

2 : HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响

3 : SSL证书要钱，而且证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

--------

## HTTP1.0、HTTP1.1和HTTP2.0的区别

### 区别一 (多路复用)
在http1.x中，为了性能考虑，通常会引入雪碧图、将小图内联、使用多个域名等方式，这一切是因为浏览器限制了同一个域名下的请求数量，由于页面需要请求很多资源，对头阻塞会导致在达到最大的请求量时，剩余的请求资源得等到其他资源请求完成之后才能发起请求。

而在http2.0中，因为引入了`多路复用`，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。

### 区别二
http1.0需要使用keep-alive参数告知服务器建立一个长连接，但是http1.1默认支持长连接

### 区别三 (二进制格式编码)
http1.x都是通过文本的形式传输数据，在http2.0中引入了新的编码机制，所有的传输数据都会被分割，并采用`二进制格式编码`

### 区别四 (服务器Push)
在http2.0中，服务端可以在客户某个请求后，主动推送其他资源。比如某些资源客户端一定是会请求的，这时候可以采用`服务端的push技术`，提前给客户端推送必要的资源，这样减少延迟时间。

### 区别五 (Header压缩)
http1.x中，以文本的形式传输header，在header携带cookie情况下，可能每次都需要重复传输几百到几千的字节

在http2.0中，使用了HPACK压缩格式对传输的header进行编码，减少了header的大小。在网络中传输会更快。

--------

## 从输入URL到页面加载完成的过程 

让我们思考一个问题，你在浏览器中输入 : www.baidu.com 的时候，在你按下回车的那一瞬间，发生了什么事情，为什么能够在你按下之后，就能将百度的首页返回？

“ WC，很简单啊，就是发送一个请求然后就获取了呗~”   emmmm，很简洁的答案。那么具体是为什么呢？直到我看了阮一峰的互联网协议入门（一）之后，才明白原因。耐心的小伙伴可以去看一看阮一峰的教程。如果是想简单知道，那么就继续往下看哈~

所谓的网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。那么发送这个包，需要知道两个地址：

```javascript
    · 对方的MAC地址

    · 对方的IP地址
```
有了这两个地址，数据包才能准确送到接收者手中。但是，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关转发。

好了，看到这，就有人想要问了，什么是MAC地址？根据以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。

<img src="https://upload-images.jianshu.io/upload_images/7885162-683a3337d7c5d7b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">

什么？你仿佛在逗我，我只知道我自身网卡MAC地址，我怎么知道他的网卡MAC地址？

根据ARP协议，就可以解决这个问题，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送

emmmm，那我知道了他的MAC地址，我该怎样才能把数据包准确送到接收方？

答案就是： 以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。这种方式就叫做 “广播”。

比如：1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"（标头会有接收者的MAC地址），找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。

听着有点晕？那我再举个例子：A班的小明向B班的小红表白，但是他只知道她叫小红(MAC独一无二，不存在相同情况)，不知道长相，于是给B班的所有同学都写了一封情书，B班的每位同学都会收到来自小明的信，他们就会读取这封信的接收者名字，和自己的名字比较，如果两者相同，就接受这封信，不同就丢弃。

这时候你又要问了，在同一个子网络可以通过 “广播” 的形式去获得对方的MAC地址，可是如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，该咋办呢？

这时候就必须通过网关转发。

不懂？那我举个例子，三年级的小红要写一封信给四年级的小张，可是不是同一个年级咋办，这时候小红发现，她的室友小A和小张的室友小B是邻居，于是她对小A说 ：“ 喂，我把这信给你，你交给你邻居小B，让他帮忙交给小张 ” 。最终，信交到了小张的手里。这里小A和小B就充当了网关的职责。

扯那么多，我们来个实例讲解一下，到底按下的那一瞬间发生了什么！

我们知道，发送数据包和请求，必须要知道对方的IP地址，可是我们现在只知道域名，不知道对方的IP地址咋办，这时候DNS就发挥作用了。

---------
### 老哥，走一个例子流程
<!--more-->
#### DNS发挥超强作用
当我们在浏览器中输入  :  www.baidu.com 之后，会给DNS服务器发送一个DNS数据包，告诉DNS ： “喂，我要访问www.baidu.com，你把他的IP地址给我”，然后DNS服务器做出响应，告诉我们 ： “ 百度的IP地址是111.111.111.111 ”。于是，我们知道了对方的IP地址。（假设百度的IP地址是111.111.111.111）

#### 计算是否同一个子网络
我们这时候就要判断他的这个IP地址和我的IP地址是不是同一个子网络了，不是同一个子网络就要通过网关转发。比如我们的子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对百度的IP地址111.111.111.111也做一个AND运算，计算结果为123.123.123.0。这两个结果不相等，所以结论是，百度与本机不在同一个子网络。因此，我们要向百度发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。

### TCP三次握手，发送HTTP包，TCP包，IP包等
在按下的那一瞬间名，浏览器建立一条与目标Web服务器的TCP连接（三次握手），发送一个HTTP请求，通过TCP协议，将HTTP请求的内容获取。也就是TCP数据包，加上嵌入HTTP的数据包。

TCP数据包再嵌入到IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是111.111.111.111（百度）。然后IP数据包里头加上嵌入的TCP数据包

IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到)

### 网关发挥作用，流弊啊，老铁
经过多个网关的转发，百度的服务器111.111.111.111，收到了这四个以太网数据包。根据IP标头的序号，百度将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

### 关闭连接，浏览器解析文档

### 如果文档中有资源，重复前三条动作，一直到资源全部加载完毕
