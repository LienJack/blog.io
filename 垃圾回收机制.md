---
title: 垃圾回收机制
date: 2018-10-08 15:27:10
tags:
---
## 垃圾回收机制
为什么要有垃圾回收这鬼玩意 ？由于字符、数组没有固定的大小所以当他们的大小已知时，才能对他们进行动态的存储分配。js在每一次创建字符串、数组、对象等时，解释器必须分配内存来存储那个实体。只要分配了内容，最终都要释放，不然解释器将会消耗完系统中所有可用的内存。导致系统崩溃(好像很牛逼的样子)

<!-- ![image](https://github.com/PDKSophia/ONE_WORD/raw/master/images/g2.gif) -->

> 各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数

#### 标记清除
```base
这是js最常用的垃圾回收方法，当变量进入执行环境时，就标记着这个变量为 “ 进入环境 ” (come on ~)，从逻辑上来讲不能释放 “进入环境” 的变所占用的内存，因为只要变量进入环境，意味着可能会用到该变量。当变量离开环境则标记为 “ 离环境 ”

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
```
#### 引用计数
```base
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。
相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。
```

#### 你以为这就结束了吗 ? NO ！
博主之前面试，有个题目就是问如果两个对象通过各自的属性相互引用，会出什么情况呢 ？ 如何解决 ？

```javascript
    function problem() {
        var objA = new Object();
        var objB = new Object();

        objA.someOtherObject = objB;
        objB.anotherObject = objA;
    }
```
在这个例子中，objA和objB通过自身属相互引用，也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。

如何解决呢 ？ 手切断他们的循环引用 ！
```javascript
    objA.someOtherObject = null
    objB.anotherObject = null
```
