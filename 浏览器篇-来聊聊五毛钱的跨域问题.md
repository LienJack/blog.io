---
title: 浏览器篇-来聊聊五毛钱的跨域问题
date: 2018-08-30 15:00:49
tags:
---
## 跨域
### 什么是跨域 ？ 
这是一个老生常谈的问题了，作为一个前端开发，不可避免的就是跨域问题，常常跨域问题都是丢给后端处理，然后前端看戏，但是这里还是要说一下跨域的方法。

跨域 : 是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

### 同源限制
+ 端口相同
+ 协议相同
+ 域名相同

三者符合才能叫做同源，比如域名A下的request.html 发送ajax 请求域名B下的respone.html。是不被允许的。因为这里域名不同，不属于同源

不被允许的意思是，浏览器还是会发出这个请求，但是它会拦截响应内容，如果发现响应header中"Access-Control-Allow-Origin"设置的允许访问的源没有包含当前源，则拒绝将数据返回给当前源。（这就是很多博客中没有提到的一个坑）

### 常见跨域场景
```javascript
    http://a.com/a.html             调用     http://a.com/server.php        允许，非跨域
 
    http://a.com/a.html             调用     http://b.com/server.php        跨域，域名不同

    http://a.com:3000/index.html    调用     http://a.com:4000/server.php   跨域，端口不同

    https://a.com/a.html            调用     httpL://a.com/server.php       跨域，协议不同
```

### 常见的方法
1 ： Jsonp跨域

`jsonp`跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信

`本质`是利用了标签具有可跨域的特性，将数据使用json格式用一个函数包裹起来,然后在进行访问的页面中定义一个`相同函数名`的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们有定义了一个同名的函数，所以json格式的数据，就做完参数传递给了我们定义的同名函数了，这样就完成了跨域数据交换。
原生方式的jsonp

```javascript
    let script = document.createElement('script')

    script.src = 'http://b.com/login?username=pdk&callback=callback'

    document.body.appendChild(script)

    function callback(res) {
        console.log(res)            //打印返回的请求数据
    }
```

Jquery实现jsonp

```javascript
    $.ajax({
        url : url,
        method : 'get',
        data : {},
        dataType : 'jsonp',     // 请求方式是jsonp
        jsonpCallback : 'callback',     // 回调函数
    })

    // 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求
```

2 : 服务器端做手脚，这里我以php举例子，也就是在php中添加允许访问的域
<!--more-->
```javascript
    // 指定允许其他域名访问  
    header('Access-Control-Allow-Origin:*');    // *允许所有域名访问
    // 响应类型  
    header('Access-Control-Allow-Methods:GET, POST, PUT, DELETE, OPTIONS');  
    // 响应头设置  
    header('Access-Control-Allow-Headers:Origin, X-Requested-With, Content-Type, Accept, authKey, sessionId'); 
```

3 : document.domain + iframe 跨域 （我没用过）

4 : window.name + iframe 跨域 （我也没用过）

5 : postMessage跨域 （我还是没用过）

```javascript
    // data 要传递的数据
    // origin 指明目标窗口的源
    postMessage(data,origin) 

    // 具体使用请百度 ： “ postMessage ”
```

6 : Nginx反向代理

反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

在nginx配置文件 "nginx.conf" 中修改信息
```javascript
    // 第一种方式, 在服务器端的nginx.conf 中添加配置
    http {
        ......
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Headers X-Requested-With;
        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
        ......
    }

    // 第二种方式，在客户端的nginx.conf 中利用反向代理
    server {
        listen       8000;
        server_name  localhost;
        location / {
            proxy_connect_timeout 1s;
            proxy_read_timeout 1s;
            proxy_send_timeout 1s;
            add_header 'Access-Control-Allow-Origin' '*'; #允许来自所有的访问地址
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Methods' 'GET, PUT, POST, DELETE, OPTIONS'; #支持请求方式
            add_header 'Access-Control-Allow-Headers' 'Content-Type,*';
        }

    }
```
nginx是一个高性能的web服务器，常用作反向代理服务器。nginx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。

通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的

简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实的服务器，让它以为这个http请求是直接来自与用户浏览器的。

7 : CORS实现跨域 （这我也没用过，给大家丢脸了）

各位小伙伴自行找些文章哈～

### 再说一句
我用的都是jsonp，或者ajax实现跨域，vue中可以设置proxy实现跨域，再不行用的是nginx跨域。其他的都没用过了，告辞，打扰了！



# 相关链接
个人简历 : http://www.pengdaokuan.cn

个人博客 : http://blog.pengdaokuan.cn:4001

