---
title: 浏览器篇-来聊聊五毛钱的跨域问题
date: 2018-08-30 15:00:49
tags:
---
## 跨域
### 什么是跨域 ？ 
这是一个老生常谈的问题了，作为一个前端开发，不可避免的就是跨域问题，常常跨域问题都是丢给后端处理，然后前端看戏，但是这里还是要说一下跨域的方法。

跨域 : 是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

### 同源限制
+ 端口相同
+ 协议相同
+ 域名相同

三者符合才能叫做同源，比如域名A下的request.html 发送ajax 请求域名B下的respone.html。是不被允许的。因为这里域名不同，不属于同源

不被允许的意思是，浏览器还是会发出这个请求，但是它会拦截响应内容，如果发现响应header中"Access-Control-Allow-Origin"设置的允许访问的源没有包含当前源，则拒绝将数据返回给当前源。（这就是很多博客中没有提到的一个坑）

### 常见跨域场景
```javascript
    http://a.com/a.html             调用     http://a.com/server.php        允许，非跨域
 
    http://a.com/a.html             调用     http://b.com/server.php        跨域，域名不同

    http://a.com:3000/index.html    调用     http://a.com:4000/server.php   跨域，端口不同

    https://a.com/a.html            调用     httpL://a.com/server.php       跨域，协议不同
```

### 常见的方法
1 ： `Jsonp`跨域

`jsonp`跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信，但是，Jsonp只支持 `Get` 请求

`本质`是利用了标签具有可跨域的特性，将数据使用json格式用一个函数包裹起来,然后在进行访问的页面中定义一个`相同函数名`的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们有定义了一个同名的函数，所以json格式的数据，就做完参数传递给了我们定义的同名函数了，这样就完成了跨域数据交换。
原生方式的jsonp

```javascript
    let script = document.createElement('script')

    script.src = 'http://b.com/login?username=pdk&callback=callback'

    document.body.appendChild(script)

    function callback(res) {
        console.log(res)            //打印返回的请求数据
    }
```

Jquery实现jsonp

```javascript
    $.ajax({
        url : url,
        method : 'get',
        data : {},
        dataType : 'jsonp',     // 请求方式是jsonp
        jsonpCallback : 'callback',     // 回调函数
    })

    // 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求
```

2 : `服务器`端做手脚，这里我以php举例子，也就是在php中添加允许访问的域
<!--more-->
```javascript
    // 指定允许其他域名访问  
    header('Access-Control-Allow-Origin:*');    // *允许所有域名访问
    // 响应类型  
    header('Access-Control-Allow-Methods:GET, POST, PUT, DELETE, OPTIONS');  
    // 响应头设置  
    header('Access-Control-Allow-Headers:Origin, X-Requested-With, Content-Type, Accept, authKey, sessionId'); 
```

3 : `document.domain + iframe` 跨域 （我没用过）

4 : `window.name + iframe` 跨域 （我也没用过）

5 : `postMessage`跨域 （我还是没用过）

```javascript
    // data 要传递的数据
    // origin 指明目标窗口的源
    postMessage(data,origin) 

    // 具体使用请百度 ： “ postMessage ”
```

6 : `Nginx反向代理`

反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

在nginx配置文件 "nginx.conf" 中修改信息
```javascript
    // 第一种方式, 在服务器端的nginx.conf 中添加配置
    http {
        ......
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Headers X-Requested-With;
        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
        ......
    }

    // 第二种方式，在客户端的nginx.conf 中利用反向代理
    server {
        listen       8000;
        server_name  localhost;
        location / {
            proxy_connect_timeout 1s;
            proxy_read_timeout 1s;
            proxy_send_timeout 1s;
            add_header 'Access-Control-Allow-Origin' '*'; #允许来自所有的访问地址
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Methods' 'GET, PUT, POST, DELETE, OPTIONS'; #支持请求方式
            add_header 'Access-Control-Allow-Headers' 'Content-Type,*';
        }

    }
```
nginx是一个高性能的web服务器，常用作反向代理服务器。nginx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。

通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的

简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实的服务器，让它以为这个http请求是直接来自与用户浏览器的。

7 : `CORS实现跨域`

通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访、问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。

` CORS(Cross-Origin Resource Sharing，跨源资源共享) ` 定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。<strong>CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</strong>

比如一个简单的使用 ` GET ` 或 ` POST ` 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在 发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息(协议、域名和端口)，以便服务器根据这个头部信息来决定是否给予响应。比如下边这个示例:

```javascript
  origin: http://www.pengdaokuan.cn
```
如果服务器认为这个请求可以接受，就在 `Access-Control-Allow-Origin` 头部中回发相同的源信息(如果是公共资源，可以回发 " * " )

```javascript
  Access-Control-Allow-Origin: http://www.pengdaokuan.cn
```

如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意, *请求和响应都不包含 cookie 信息*。

### IE 对 CORS 的实现
在IE8中，引入了 ` XDR(XDomainRequest) ` 类型，这个对象与 XHR 类似，但能实现安全可靠的跨域通信, 它与XHR的不同之处如下 :

- `cookie` 不会随请求发送，也不会随响应返回。

- 只能设置请求头部信息中的 `Content-Type` 字段。

- 不能访问响应头部信息。

- 只支持 `GET` 和 `POST` 请求

这些变化使 <strong>CSRF(Cross-Site Request Forgery，跨站点请求伪造)</strong> 和 </strong>XSS(Cross-Site Scripting，跨站点脚本)</strong>的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据(用户代理、来源页面等) 来决定是否设置 ` Access-Control- Allow-Origin ` 头部。作为请求的一部分，Origin 头部的值表示请求的来源域，以便远程资源明确地识别 XDR 请求。

XDR 对象的使用方法与 XHR 对象非常相似。也是创建一个 XDomainRequest 的实例，调用 open() 方法，再调用 send()方法。但与 XHR 对象的 open()方法不同，<strong>XDR 对象的 open()方法只接收两个参数: 请求的类型和 URL。</strong>也就是没有第三个参数，决定是否异步或同步，因为所以的 XDR 请求都是异步的

> 所有 XDR 请求都是 `异步执行` 的，不能用它来创建同步请求。请求返回之后，会触发 load 事件，响应的数据也会保存在 responseText 属性中

```javascript
  var xdr = new XDomainRequest()
  xdr.onload = function () {
    console.log(xdr.responseText)
  }
  xdr.open('get', 'http://www.pengdaokuan.cn/xxx')
  xdr.send(null)
```

在接收到响应后，只能访问响应的原始文本; 没有办法确定响应的状态代码。而且，只要响应有效就会触发 load 事件，如果失败(包括响应中缺少 `Access-Control-Allow-Origin` 头部)就会触发 error 事件。遗憾的是，除了错误本身之外，没有其他信息可用，因此唯一能够确定的就只有请求未成功了。要检测错误，可以像下面这样指定一个 onerror 事件处理程序。

```javascript
  var xdr = new XDomainRequest()
  xdr.onload = function () {
    console.log(xdr.responseText)
  }
  xdr.onerror = function () {
    console.log('an error occurred')
  }
  xdr.open('get', 'http://www.pengdaokuan.cn/xxx')
  xdr.send(null)

```
为支持 POST 请求，XDR 对象提供了 `contentType` 属性，用来表示发送数据的格式，如下面的例子所示。
```javascript
  var xdr = new XDomainRequest()
  xdr.onload = function () {
    console.log(xdr.responseText)
  }
  xdr.onerror = function () {
    console.log('an error occurred')
  }
  xdr.open('post', 'http://www.pengdaokuan.cn/xxx')
  xdr.contentType = "application/x-www-form-urlencoded" // 发送数据的格式
  xdr.send(null)

```

### 其他浏览器对CORS的实现
Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 平台中的 WebKit 都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。

与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。如下

- 不能使用 setRequestHeader()设置自定义头部。

- 不能发送和接收 cookie。

- 调用 getAllResponseHeaders() 方法总会返回空字符串。

> getAllResponseHeaders() 方法则可以取得一个包含所有头部信息的长字符串。

### 带凭证的请求
默认情况下，跨源请求不提供凭据(cookie、HTTP 认证及客户端 SSL 证明等)。通过将 `withCredentials` 属性设置为 true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应。

```javascript
  Access-Control-Allow-Credentials: true
```

### 跨浏览器的 CORS
由于 IE 对 CORS 的请求是 XDR，而其他浏览器对 CORS 的请求是 XHR，所以存在差异，但所有浏览器都支持简单的(非 Preflight 和不带凭据的)请求因此有必要实现一个跨浏览器的方案。检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性。再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了。

```javascript
  function createCORSRequest (method, url) {
    var xhr = new XMLHttpRequest()
    if ('withCredentials' in xhr) {
      xhr.open(method, url, true)
    } else if (typeof XDomainRequest != 'undefined') {
      xhr = new XDomainRequest()
      xhr.open(method, url)
    } else {
      xhr = null
    }
    return xhr
  }

  var request = createCORSRequest('get', 'http://www.pengdaokuan.cn/request.php')
  if (request) {
    request.onload = function () {
      if ((request.status >= 200 && request.status < 300) || request.status == 304) {
        console.log(request.responseText)
      } else {
        console.log("Request was unsuccessful: " + request.status)
      }
    }
    request.onerror = function () {
      console.log('an error occurred')
    }
    request.send()
  }
```

### 再说一句
我用的都是jsonp，或者ajax实现跨域，vue中可以设置proxy实现跨域，再不行用的是nginx跨域。其他的都没用过了，告辞，打扰了！



# 相关链接
个人简历 : http://www.pengdaokuan.cn

个人博客 : http://blog.pengdaokuan.cn:4001

