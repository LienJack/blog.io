## TCP的三次握手和四次挥手
### 三次握手
<img src="http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png">

```javascript
    1 : 客户clientA发送SYN标志位和随机产生一个值seq=J给服务器B，此时处于SYN_SEND状态

    2 : 服务器B被动打开，处于Listen状态，服务器B接收到客户端A发送的请求后，如果同意请求连接，发送SYN标志位 和 ACK=J+1，随机产生一个值seq=K，此时进入到SYN_RCVD状态
    
    3 : 客户端A收到服务器B的确认之后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器B，此时进入established状态，服务器B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，此时进入established状态
```
为什么不是二次握手 ？
> 为了解决已失效的请求报文又传到B，因而产生错误。

比如A发送了一个请求给B，希望建立连接。但是由于此时此刻网络节点长或者拥塞滞留，这本来是一个失效的报文请求，但是因为A有一个超时时间，这时候会被认为超时重传。如果是两次握手请求，那么B这时候收到这个 “ 延迟 ”的报文请求A，会认为A又发送请求，于是B发送确认，这时候又建立起了连接。

### 四次挥手
<img src="http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png">

```javscript
    1 : 客户端A发送一个FIN告知服务器B，要结束连接，此时进入FIN_WAIT_1 状态

    2 : 服务器B收到FIN后，发送一个ACK给客户端A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器B进入CLOSE_WAIT，处于半关闭状态，也就是A不向B发数据，但B要向A传数据，客户端处于FIN_WAIT_2状态

    3 : 服务器B发送一个FIN，这时B没有东西要向A传了，所以发送FIN告知A可以关闭了，然后进入LAST_ACK状态

    4 : 客户端A收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器B，确认序号为收到序号+1，注意，这里还未释放掉，必须经过Time-wait(等待时间)，服务器B才进入CLOSED状态，完成四次挥手。
```
