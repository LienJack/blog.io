## 栈

### 简单介绍一下

<ul>
  <li>栈是在表尾进行插入或删除操作的线性表</li>
  <li>对栈来说，表尾称为栈顶，表头称为栈底</li>
  <li>LIFO，先进后出</li>
</ul>

### 基本形态

```javascript
    1 . 栈空
        - 条件: Stack.length == NULL
        - 操作: 不允许出栈

    2 . 栈满
        - 条件: Stack.length == MaxLength
        - 操作: 不允许入栈

    3 . 不空也不满
        - 条件: 0 < Stack.length < MaxLength
        - 操作: 可以入栈，也可以出栈

```

### 实现一下

这里封装了基本方法

| 方法 | 描述 |
| :------: | :------: | 
| pushStack(element) | 将元素element入栈 |  
| popStatck() | 出栈 | 
| isEmpty | 判断栈是否为空 | 
| getCount() | 获取栈的长度 |  
| getHeader() | 获取栈底元素 | 
| getTail() | 获取栈顶元素 | 

```javascript
  可以把栈看成是数组的一个子集，所以这里使用数组来实现

  function Stack () {
    var stack = []

    this.pushStack = function (element) {
      stack.push(element)
    }

    this.popStatck = function () {
      let popelement = stack.pop()
      console.log('出栈元素为: ', popelement)
    }

    this.isEmpty = function () {
      if (stack.length === 0) {
        return true
      } else {
        return false
      }
    }

    this.getCount = function () {
      return stack.length
    }

    this.getHeader = function () {
      if (stack.length === 0) {
        return null
      } else {
        return statck[0]
      }
    }

    this.getTail = function () {
      return stack[this.getCount() - 1]
    }

    this.show = function () {
      console.log('栈底至栈顶为: ', stack.join(' '))
      console.log('依次出栈顺序为: ', stack.reverse().join(' '))
    }

  }
  
  var stack = new Stack()
  stack.pushStack('a')
  stack.pushStack('b')
  stack.pushStack('c')
  stack.pushStack('d')
  stack.pushStack('e')
  stack.pushStack('f')
  stack.popStatck()
  // console.log(stack.getHeader())
  // console.log(stack.getTail())
  // console.log(stack.getCount())
  stack.show()

```

### 面试常考
#### 括号的匹配
```javascript
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

输入: "()"
输出: true

输入: "()[]{}"
输出: true

输入: "(]"
输出: false

输入: "([)]"
输出: false

输入: "{[]}"
输出: true

```
```javascript
  // 可以利用栈的形式来实现

  // 当匹配到 左 ( { [ 的时候，入栈。匹配到 右 ) } ] 的时候出栈，判断是否是同一组括号

  function isVilidate (str) {
    let map = {
      '[': -1,
      ']': 1,
      '{': -2,
      '}': 2,
      '(': -3,
      ')': 3
    }

    let stack = []
    for (let i = 0; i < str.length; i++) {
      if (map[str[i]] < 0) {
        stack.push(map[str[i]])
      } else {
        let popNum = stack.pop()
        if (popNum + map[str[i]] !== 0) {
          console.log('不是一组有效的括号')
          return false
        }
      }
    }

    if (stack.length > 0) { // 排除 {}[]( 的情况，这时 stack 数组中还存在 ( 
      return false 
    }

    return true
  }

  console.log(isVilidate('{}{}([])'))

```

#### 行编辑程序


```javascript
编写一函数 editString() ，输入一行文本字符，当发现一个退格符 "#" 时，表示前一个字符无效； 当发现一个 "@" 时，表示当前行中的字符均无效

输入: "whli##ilr#e(s#*s)"
输出: while(*s)

输入: "ticknet@hunst(*s=#++)"
输出: hnust(*s++)

```
```javascript
  // 可以用栈实现

  // 对每个字符做判断，如果既不是#也不是@，则压入栈

  // 如果遇到#，则从栈中pop出来前一个字符，如果是一个@，则清空这个栈

  function editString (str) {
    let stack = []
    
    for (let i = 0; i < str.length; i++) {
      switch (str[i]) {
        case '#': 
          if (stack.length !== 0) { // 排除 第一个字符就是 #，因为这时候栈为空，无法pop
            let popElement = stack.pop()
            console.log('遇到#，pop前一个元素: ', popElement)
          }
          break
        case '@':
          stack = []
          break
        default: 
          stack.push(str[i])
      }
    }

    return stack.join('')
  }

  console.log(editString('whli##ilr#e(s#*s)'))
  
```
