---
title: 浏览器篇-事件机制
date: 2018-08-30 15:02:15
tags:
---
## 事件机制
这是博主看了红皮书《JavaScript高级程序设计》然后总结的，如有错误，请指出

### 事件冒泡
简单来讲，事件开始由从具体的元素(触发的节点)向上传播到不具体的节点(文档)。
```javascript
    // 这里举个例子
    <!DOCTYPE html>
    <html>
        <head>
            <title>Example</title>
        </head>
        <body>
            <div>
                <p事件冒泡</p>
            </div>
        </body>
    </html>

    // 当你点击页面中的p标签，那么这个click事件就会按照如下顺序传播
    1 . <p>
    2 . <div>
    3 . <body>
    4 . <html>
    5 . document
    
    // 这就是事件冒泡  
```
### 事件捕获
从不太具体的节点到具体的节点。
```javascript
    // 这里举个例子
    <!DOCTYPE html>
    <html>
        <head>
            <title>Example</title>
        </head>
        <body>
            <div>
                <p>事件冒泡</p>
            </div>
        </body>
    </html>

    // 当你点击页面中的p标签，那么这个click事件就会按照如下顺序传播
    1 . document
    2 . <html>
    3 . <body>
    4 . <div>
    5 . <p>
    // 这就是事件捕获  
```
### 三个阶段
+ 事件捕获阶段
+ 处于目标阶段
+ 事件冒泡阶段

按照上边的例子，那么下面是三个阶段的讲解
+ 事件捕获阶段 ：document - html - body - div
+ 处于目标阶段 ：p
+ 事件冒泡阶段 ：div - body - html - document

<!--more-->
### 事件处理程序
"DOM2" 定义了两个处理程序的操作， addEventListener() 和 removeEventListener()

```javascript
    // addEventListener(处理的事件名， 处理程序的函数， 布尔值)
    let btn = document.getElementById('login')
    btn.addEventListener('click', function(){
        console.log('login now')
    }, false)

    // 当第三个参数，boolean值, 默认false
    // true， 表示捕获阶段调用事件处理程序
    // false，表示冒泡阶段调用事件处理程序
    // 如果同一个btn，绑定多个事件处理程序，那么会按照顺序触发

    // 如果我们希望只触发目标函数，不希望冒泡或者捕获，这时候通过stopPropagation来阻止
    // stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。
    btn.addEventListener('click', (event) => {
        event.stopImmediatePropagation()
        console.log('login now')
    }, false)

    通过addEventListener添加的事件处理只有通过removeEventListener来移除
```

### IE事件处理程序
IE实现了与DOM中类似的两个方法， attachEvent() 和 detachEvent()，接收两个参数，事件处理程序名称和 事件处理程序函数

```javascript
    let btn = document.getElementById('register')
    btn.attachEvent('onclick', function(){
        console.log('register now')
    })

    // 这里的第一个参数是onclick，而不是DOM 中的click
    // 在使用attachEvent()方法的情况下，事件处理程序在全局作用域中运行
    // 即 this === window
    // 如果同一个btn，绑定多个事件处理程序，那么会按照相反顺序触发
    通过attachEvent添加的事件处理只有通过detachEvent来移除
```
### 事件代理(事件代理)
什么叫做事件委托， 其实事件委托就是利用事件冒泡，制定一个事件处理程序，管理某一类型的所有事件。

举个例子 : 我有100个 li 节点，每个li都有相同的click事件，那么我们会怎么做呢 ？
```javascript
    <ul id="demo_ul">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>

    window.onload = function(){
        let uls = document.getElementById('demo_ul')
        let lis = uls.getElementsByTagName('li')
        for(let i =0; i < lis.length; i++) {
            lis[i].onclick = function(){
                console.log('我是第' + i + '个li节点')
            }
        }
    }
```
是不是很熟悉？但是如果每个可点击的元素都采用这种方式，那么就会有数不清的代码用于添加事件处理程序，此时，用事件委托，贼舒服

这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的

Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置

```javascript
    window.onload = function(){
        let uls = document.getElementById('demo_ul')
        uls.onclick = function(ev){
            var ev = ev || window.event
            var target = ev.target || ev.srcElement;
    　　　　 if(target.nodeName.toLowerCase() == 'li'){
    　　　　     alert(target.innerHTML);
    　　　　 }
        }
    }
```
上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？
```javascript
    <ul id="box">
        <li id="add"></li>
        <li id="remove"></li>
        <li id="move"></li>
        <li id="select"></li>
    </ul>

    // 正常流程
    window.onload = function(){
        var Add = document.getElementById("add");
        var Remove = document.getElementById("remove");
        var Move = document.getElementById("move");
        var Select = document.getElementById("select");
            
        Add.onclick = function(){
            alert('添加');
        };
        Remove.onclick = function(){
            alert('删除');
        };
        Move.onclick = function(){
            alert('移动');
        };
        Select.onclick = function(){
            alert('选择');
        }
    }

    // 事件代理
    window.onload = function(){
        var oBox = document.getElementById("box");
        oBox.onclick = function (ev) {
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if(target.nodeName.toLocaleLowerCase() == 'input'){
                switch(target.id){
                    case 'add' :
                        alert('添加');
                        break;
                    case 'remove' :
                        alert('删除');
                        break;
                    case 'move' :
                        alert('移动');
                        break;
                    case 'select' :
                        alert('选择');
                        break;
                }
            }
        }
    }
```
### 相关链接
个人简历 : http://www.pengdaokuan.cn

个人博客 : http://blog.pengdaokuan.cn:4001

